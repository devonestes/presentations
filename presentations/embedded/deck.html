---
layout: presentation
title: Embedded Application Development (for Web Developers)
permalink: /embedded_development/

---
layout: true
.watermark-left[@devoncestes]
.watermark-middle[GOTO Berlin 2019]

---
class: center, middle, gotober-intro

---
class: center, middle, headline

## Embedded Application Development
### &nbsp;

---
class: center, middle, headline

## Embedded Application Development
### *for Web Developers

???
My name is Devon...

For pretty much all of my career I've been a web developer...

For the last 4 years I've been doing Elixir/Erlang...

Last year, I was contacted by a company who wanted to hire me to work on their
applications. One was something I had seen several times before - a
high-throughput GraphQL API.

But the second was something new to me - an embedded application.

This company was building Point of Sale systems for restaurants and retail
chains in the US, and those POS systems communicated back to that central API
for all kinds of helpful things for owners and operators of these retail
locations.

And powering these POS systems was embedded software, running on dozens of
different kinds of hardware in hundreds of locations across a _very_ large
country. A huge selling point for this company is that their software would be
able to run on your existing POS hardware, and that was a huge challenge.

To put this challenge into web development terms, imagine you're building a web
app that needs to run _perfectly_ in every web browser that's been used over
the last 20 years - and yes, I mean everything from Internet Explorer 5 to
today!

Writing software for one hardware platform isn't so bad, but writing software
for dozens of them - not to mention drivers for dozens of possible peripherals
- is really quite hard!

---
class: center, middle

![Tesla](/assets/images/tesla.jpg)

???
This is also now software!

Tesla famously runs millions of lines of code through their cars, and that
software is _critical_ to the operation of their cars.

---
class: center, middle

![Tesla](/assets/images/tesla-ota-update.png)

???
We know that this software is critical because it controls things like how long
your battery lasts in your car.

---
class: center, middle

![Tesla](/assets/images/fridge-open-source-1.png)

???

There is software just about everywhere these days. In fact, this a page from
the manual for a Samsung refrigerator.

---
class: center, middle

![Tesla](/assets/images/fridge-open-source-2.png)

???

When you go to the link they mention, you see something like this, because these
companies need to comply with the licenses of the open source software they use
somehow!

---
class: center, middle, headline

## Internet of Things

???
It's here, but it's different. The thing that I learned really quickly on this
project was that while the code might be the same, there are some restrictions
that change a lot of things. Most importantly, on many of these devices, you
can't just push an update whenever you want. And when you can't push updates
whenever you want, a whole lot of stuff falls down in the way software is
developed today.

---
class: center, middle, max-img-width-940

# Project success

![Linear growth](/assets/images/linear-growth.png)

???

The thing with agile software development is that project success is correlated
to a team's ability to gather feedback about their software and then iterate
based on that feedback. This feedback takes a lot of forms, but that's the
theory behind agile.

With embedded software, both the ability to gather feedback and the ability to
iterated based on that feedback is severely, severely limited. It depends of
course on the specific project, but this was very much the case for the project
I was working on, and is also the case for a great deal of embedded projects.

This means that you need to fall back to essentially a version of waterfall, and
in wat

---
class: center, middle, max-img-width-940

# Predicting the future!

![Crystal Ball](/assets/images/crystal-ball.jpg)

???

I'm not talking about knowing who is going to win the Super Bowl this year.

This is about predicting how your software is going to need to change after you
deploy it.

---
class: center, middle, headline

## Built the wrong thing
## &nbsp;
## &nbsp;

---
class: center, middle, headline

## Built the wrong thing
## Bugs
## &nbsp;

---
class: center, middle, headline

## Built the wrong thing
## Bugs
## Security vulnerabilities

---
class: center, middle, headline

# Product Design

???
Before the product is even built, how do you design it? You can't rapidly
iterate on designs because you can't control if users actually update or not.

Getting your product right to meet your users' needs is a really tricky process,
and not being able to rapidly iterate makes it even more difficult!

You build and test mockups and do lots of user testing. Alpha and Beta users are
crucial.

=======================================================================
Design sprints are really helpful here (5 minutes on design sprints, links to
more resources).
=======================================================================

---
class: center, middle, headline

## KISS
## &nbsp;

---
class: center, middle, headline

## KISS
## Design Sprints

---
class: center, middle, fullscreen-image

![Design sprint](/assets/images/warehouse.gif)

---
class: center, middle, headline

## KISS
## Keep It Simple, Stupid

---
class: center, middle, headline

# Design Sprints

---
class: center, middle, headline

![Design sprint](/assets/images/design-sprint.png)

---
class: center, middle, headline

# Testing

???
How many of you have some sort of monitoring/observability platform that allows
you to monitor production systems?

How many of you test in production?

I have some bad news for you if you put your hand down after the first question
- you're testing in production! If you had total confidence that your
application was working 100% correctly in all situations, then
monitoring/observability is unneeded.

You can't test in production when you don't have access to production devices.
This makes replicating production-like usage of your application extremely
important.

Show picture of Facebook mobile testing:

"In each rack, above the tangle of cables and phones, sits a camera, recording
every onscreen movement in case a developer needs to review a specific hiccup."

A strong type system is really helpful. This gives us a baseline of confidence
in the "correctness" of your program. Again, if deploying is difficult - or
impossible - then you really want to find bugs before your users do.

=====================================
Property testing is extremely helpful (main section - 5 minutes)
=====================================

---
class: center, middle

![](/assets/images/property-testing.jpg)

---
class: center, middle, fullscreen-image

![](/assets/images/phone_testing.jpg)

---
class: center, middle, headline

# Debugging

???
Running an application on dozens of different hardware platforms is really
tricky to get right! How do you debug when things go wrong?

When it comes to debugging, nothing comes close to the helpfulness of connecting
to a running OTP application.

Even finding out if you have bugs can be really tricky since you might need
users to report them, and they often don't.

=================================================
Show a little bit of the power of the observer (main section - 5 minutes)
=================================================

---
class: center, middle, headline

# Security

???
The "S" in IoT stands for security.

I know what many of you might have been thinking a bit. "Why isn't he mentioning
C or C++ in a talk on embedded software?"

https://www.coreinfrastructure.org/programs/census-project/
Main Language: If the projectâ€™s main language is C or C++, add 2 points.

With great power comes great buffer overflow bugs - Spiderman meme.

You need to be able to do this without opening up your users to huge security
issues. Especially in my case, where money and financial information is
involved and it's connected to the internet, we needed to be rock solid.

Do you really want to run code written by strangers on the internet on your
users' devices?

I love that we trust the OSS community as much as we do, but this is potentially
dangerous. There are a whole host of possible attack vectors, and the
combinatorial explosion of possible attack targets makes using dependencies a
risky business.

Limit your use of dependencies - this basically rules out JavaScript.

---
class: center, middle, headline

# The web?

---

class: center, middle, gotober-outro
